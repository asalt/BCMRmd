---
title: "GSEA"
author: "BCM MSPC"
date: "`r Sys.Date()`"
tidy: formatR
output:
  html_document:
    code_folding: hide
    highlight: zenburn # pygments, kate, monochrome, zenburn
    toc: yes
    includes:
      #in_header: header.html 
  # formula:
  #   value: ~ SampleType + PDXModel
  #metadata_columns:
  #  value: SampleType, OrganSite
params:
  comparisons:
    description: description
    value:
      - name: "pdx_vs_src"
        contrast_column: SampleType
        group_1_value: "pdx"
        group_2_value: "src"
        subsets:
          - name: "Model_TNBC"
            filter_expression: "PDXModel == 'TNBC'"
          - name: "Model_HER2+"
            filter_expression: "'HER2' %in% PDXModel"
          # - Model_TNBC: "PDXModel == 'TNBC'"
          # - Model_HER2: "'HER2' %in% PDXModel"
      # - name: "test"
      - name: "something_else"
        contrast_column: SampleType
        group_1_value: "pdx"
        group_2_value: "src"
  gct_file:
    value: "MSPC000769_TMT11_prof_Config_data_gct_all_1.0more_nonzero_parametricBatch_plex_noCov_normtype_median_n99x10955.gct"
    description: if specified, will use this gct file
          
  output_dir: 
    value: "WebGestaltR_GSEA"
  cache_dir:
    value: "./WebGestaltR_cache"
  fdr_method:
    value: "BH"
    options: [ holm, hochberg, hommel, bonferroni, BH, BY ]
  gseaPlotFormat:
    value: svg
    options: [ png, svg ]
  gseaP:
      value: 1
      description: "The exponential scaling factor of the phenotype score. The default is 1. When p=0, ES reduces to standard K-S statistics (See original paper for more details)."
  show_result:
    value: true
    description: "Display the results, like showing your vacation photos to your friends who didn't go!"
  collapse:
    value: false
    description: "Collapse? What is this, a bad stock market? We're talking genesets here!"
  gmt:
    value:
    description: "GMT, you think it's Greenwich Mean Time? No, it's custom genesets for you, my friend!"
  only_human:
    value: false
    description: "Only humans? This isn't an exclusive club, we're including everybody's genes!"
  use_cluster2:
    value: false
    description: "Cluster2? Is that the new hot spot in town? No, it's another way to analyze gene sets!"
  geneset:
    value: hallmark
    description: "Choose your geneset like picking a wine at a fancy dinner party!"
  metric:
    value: Signal2Noise
    description: "Metrics, it's like how we rate movies, but for genes and pathways!"
  mode:
    value: Max_probe
    description: "Mode? Sounds like a fashion trend, but it's about gene expression data!"
  norm:
    value: meandiv
    description: "Normalize, like when you're trying to act cool in front of your in-laws!"
  number_of_permutations:
    value: 1000
    description: "Permutations, it's like all the different ways your GPS can take you home!"
  permute:
    value: phenotype
    description: "Permute, it's like rearranging the furniture, but for gene_sets or phenotype!"
  plot_top_x:
    value: 10
    description: "Like the top 10 movies of the year, but it's for enrichment plots!"
  rnd_type:
    value: no_balance
    description: "RND type, like deciding which side of the bed to sleep on!"
  rnd_seed:
    value: 1234
    description: "Random seed, it's like picking lottery numbers, but for your analysis!"
  scoring_scheme:
    value: weighted
    description: "Scoring scheme, like how you pick your friends... or enemies!"
  set_max:
    value: 500
    description: "Set max, like the biggest party you can imagine, but for genesets!"
  set_min:
    value: 15
    description: "Set min, it's like a small gathering for your closest genesets!"
  sort:
    value: real
    description: "Sorting, like choosing the order of your favorite TV shows on Netflix!"
  number:
    value: 9999
    description: "Number of pathways to plot, like counting how many cups of coffee you've had today!"
  group:
    value:
    description: "Specify the group for GSEA, like picking which table you want to sit at during a wedding!"
  plot_genes:
    value: false
    description: "Plotting genes, like planning your next big vacation!"
  plot_genes_sig:
    value: false
    description: "Plot significant genes, like the VIPs of the gene world!"
  annotate:
    value:
    description: "Annotate, like writing snarky comments on your friend's Facebook posts!"
  no_homologene_remap:
    value: false
  logging:
    value:
        message: TRUE
        warning: TRUE
  

end: 1

---


```{r, label=cluster-load, include=F}
library(ggplot2)
library(cmapR)
library(tidyr)
library(dplyr)
library(purrr)
library(broom)
library(magrittr)
library(scales)
library(limma)
knitr::opts_chunk$set(
  message = params$logging$message,
  warning = params$logging$warning
)

knitr::opts_chunk$set(echo = TRUE)
source("funcs.R") # make_random_gct 
```


```{r, ora-gct-check}

.params <- read_rmd_params("GSEA.Rmd")
#.gct_file <- params$gct_file[['value']]
.gct_file <- .params$gct_file$value
if (!is.null(.gct_file)){
  gct <- cmapR::parse_gctx(.gct_file)
}

#.group1 <- params$group1
#.group2 <- params$group2
if (!exists("gct")) {
  gct <- .GlobalEnv$make_random_gct()
}
```

```{r, ora-load}
library(WebGestaltR)

.organism = "hsapiens"
.enrichDatabase = "geneontology_Biological_Process_noRedundant"
.enrichMethod = "GSEA"
# enrichmethod == GSEA means interestGene data.frame with two columns, geneids and scores
.referenceSet <- "genome_protein-coding"
.isOutput <- TRUE # false only returns a dataframe with the enrichment results, useful for analyzing many combinations of interesting genes
# .outputDirectory <- params$output_dir
.projectName <- params$project_name
#WebGestaltR::listReferenceSet()
.nThreads <- 1
.output_dir <- .params$output_dir
.output_dir <- "./WebGestaltR_GSEA/"

.cache_dir <- params$cache_dir
.cache_dir <- "./WebGestaltR_cache"  
  
.n_perm <- 10
  
```
```{r, label='gsea-funcs'}

signal2noise <- function(expression_matrix, group1, group2) {
  expression_matrix <- .mat
  group1 <- .grp1_samples
  group2 <- .grp2_samples
  
  group1_expression <- expression_matrix[, group1]
  group2_expression <- expression_matrix[, group2]
  
  # group1_means <- colMeans(group1_expression)
  # group2_means <- colMeans(group2_expression)
  
  group1_means <- apply(group1_expression, 1, mean)
  group2_means <- apply(group2_expression, 1, mean)
  
  group1_var <- apply(group1_expression, 1, var)
  group2_var <- apply(group2_expression, 1, var)
  
  s2n <- (group1_means - group2_means) / (group1_var + group2_var)
  return(s2n)
}


.func2 <- function(.a_subset, .comparison){
  
  
    ( .subsets <- .comparison$subsets )
  # list with name and filter_expression
  # .a_subset <- .subsets[[1]]
  .subname <- .a_subset$name
  ( .name <- .comparison$name )
  ( .contrast_col <- .comparison$contrast_column )
  .filter_expression <- .a_subset$filter_expression
  # .filter_expression <- "all()"
  ( .subset_expression <- parse(text = .filter_expression ) )
  .metadata <- gct@cdesc %>% filter(eval(.subset_expression)) 
  
  .grp1 <- .comparison$group_1_value
  .grp2 <- .comparison$group_2_value
  .grp1_samples <- .metadata[ .metadata[.contrast_col] == .grp1, "id" ]
  .grp2_samples <- .metadata[ .metadata[.contrast_col] == .grp2, "id" ]
  .mat <- mat(gct) 
  #.mat[ ,.grp1_samples ]
  .s2n_res  <- .GlobalEnv$signal2noise(.mat, .grp1_samples, .grp2_samples) 
  .s2n_table <- tibble(GeneID = names(.s2n_res), Value = .s2n_res)
  
  if (!fs::dir_exists(.output_dir)){
    fs::dir_create(.output_dir)
  }
  #.OUTPUT_DIR <- "."
  # .project_name <- paste0(.name, "_", .subname) 
  .project_name <- paste0(.name, "_", .subname) %>% gsub("_$", "", .) # get rid of extra
  .resultant_project_dir <- file.path(.output_dir, paste0("Project_", .project_name))
  ( .resultant_project_dir )
  
  if (fs::dir_exists(.resultant_project_dir)){
    cat(paste(.resultant_project_dir, "already exists\n", "Skipping"))
    return
  }
  #.project_name <- "GSEA-test-immune"
  # else run

 cat(paste("running gsea", "outdir", .resultant_project_dir, '\n'))

  # .res <- WebGestaltR::WebGestaltR(
  #   #  enrichMethod = .enrichMethod,
  #   enrichMethod = "GSEA",
  #   interestGene = .s2n_table,
  #   interestGeneType = "entrezgene",
  #   perNum = .n_perm,
  #   organism = .organism,
  #   enrichDatabase = .enrichDatabase,
  #   referenceSet = .referenceSet,
  #   isOutput = .isOutput,
  #   nThreads = .nThreads,
  #   cache = .cache_dir,
  #   projectName = .project_name,
  #   outputDirectory = .output_dir
  # )
  # .res # data frame with geneSet, description, link, ES, NES, pValue, ..
}

  
.func1 <- function(.comparison){
  
  
  # .compariso
   # .comparison <- .comparisons$value[[1]]
    ( .name <- .comparison$name )
    ( .contrast_col <- .comparison$contrast_column )
    ( .subsets <- .comparison$subsets )
    if (is.null(.subsets)){
      .subsets <- list(  # a list with just 1 subset comparison, which is everything
        list(name='', filter_expression="all()")
      )
    }
    #.a_subset <- .subsets[[1]]
    # filter down based on
  # browser()
  .gesa_results <- .subsets %>% map(.func2, .comparison)
    #.gsea_results
}

#.metadata <- gct@cdesc %>% filter(eval(.subset_expression))
#( .comparisons <- .params$comparisons )
.comparisons$value %>%  purrr::map(.func1)
#.comparisons$value %>%  purrr::map(.func1)


# ( .comparisons <- .params$comparisons )
# ( .comparison <- .comparisons$value[[2]])
#.comparisons$value %>%  purrr::map(.func)
```

```{r, label=gsea-one-comparison-loading-testing, eval=F}
( .comparisons <- .params$comparisons$value )
( .comparison <- .comparisons[[1]])
( .comparison$name )
( .comparison$subsets )


( .comparison$subsets[[1]] )
( .comparison$subsets[[2]] )

( .comparison <- .comparisons[[1]])
#( .comparison <- .comparisons[[1]]$value)
.comparison$name
.comparison$contrast_column
.comparison$group_1_value
.comparison$group_2_value
.comparison$subsets
(.comparison[[1]]$name )
(.comparison[[1]]$name )
(.comparison[[1]]$subsets )

( .comparison$)

( .comparisons[[1]]$subset )
( .subsets <- .comparison$subsets )
#( .comparison_formula <- .comparison$formula )
( .subset <- .subsets[[1]] )
 

( .contrast_vector <- .comparison_formula %>% parse(text = .) )
(  .subset_expression <- parse(text = .subset) )

.metadata <- gct@cdesc %>% filter(eval(.subset_expression))
(.updated_comparison_formula <- paste0("filtered_metadata$", .comparison$formula))
(.contrast_vector_values <- eval(parse(text = .updated_comparison_formula)) )




run_gsea_on_subset <- function(.subset){
  ( .subset_name <- names(.subset) )
  ( .subset_expression <- parse(text = .subset[[1]]) )
  ( .subset_expression <- parse(text = .subset[1]) )
  ( .subset_expression <- parse(text = .subset) )
  .filtered_metadata <- gct@cdesc %>% filter(eval(.subset_expression))

  .subset_expression <- parse(text = .subset)
  ...
}
#.subsets %>% purrr::map()

for (.subset %in% .subsets){
  print(.subset)
}


subsets <- .comparison[1]

.subset <- subsets[[1]]
.subset
.subset_expression <- parse(text = .subset)

gct@cdesc %>% filter(eval(.subset_expression))

comp_name <- .comparison$name
  comp_formula <- .comparison$formula
  subsets <- .comparison$subsets
  
  contrast_vector <- eval(parse(text = comp_formula))
    gsea_result <- gsea_function(data, contrast_vector) # Replace with the appropriate GSEA function
    results[[comp_name]] <- gsea_result


```

```{r, gsea-gsea-go, eval=F}

#interesting_collection_of_genes <- gct@rid %>% ``
.group1 <- params$group1
.group2 <- params$group2


.organism = "hsapiens"
.enrichDatabase = "geneontology_Biological_Process_noRedundant"
.enrichMethod = "GSEA"
# enrichmethod == GSEA means interestGene data.frame with two columns, geneids and scores
.referenceSet <- "genome_protein-coding"
.isOutput <- TRUE # false only returns a dataframe with the enrichment results, useful for analyzing many combinations of interesting genes
#.outputDirectory <- params$output_dir
.projectName <- params$project_name
#WebGestaltR::listReferenceSet()
.nThreads <- 4

.cache_dir <- params$cache_dir
.cache_dir <- "./WebGestaltR_cache"  


interesting_genes <- .immune_signature_gids
#.isOutput=F
.project_name <- "GSEA-test-immune"

.res <- WebGestaltR::WebGestaltR(
  enrichMethod = .enrichMethod,
  interestGene = interesting_genes,
  interestGeneType = "entrezgene",
  organism = .organism,
  enrichDatabase = .enrichDatabase,
  referenceSet = .referenceSet,
  isOutput = .isOutput,
  nThreads = .nThreads,
  cache = .cache_dir,
  projectName = .project_name
  
)


# if we want to do any steps "manually" we can build that later
#install.packages("biomaRt")
# library(biomaRt)
# ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
# protein_coding_genes <- getBM(
#   attributes = c("ensembl_gene_id", "external_gene_name", "entrezgene"),
#   filters = "biotype",
#   values = "protein_coding",
#   mart = ensembl
# )


#.oraenrich <- WebGestaltR:::oraEnrichment(
#  interestGene = .immune_signature_gids,
#  referenceGene =
#  
#)
```
