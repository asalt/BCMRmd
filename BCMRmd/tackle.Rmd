---
title: "tackle"
author: "AlexSaltman"
date: "`r Sys.Date()`"
output: html_document
params:
  cluster_methods:
    value: [kmeans, PAM]
  cluster:
    value:
      cluster_rows:
        value: true
        description: "cluster the rows"
      cluster_columns:
        value: true
      cluster_row_slices:
        value: true
      cluster_col_slices:
        value: true
      clustering_distance_rows:
        value: euclidean
      clustering_method_rows:
        value: ward.d2
      legend_include:
        value: 
        description: "metadata variables to include"
      legend_exclude:
        value:
        description: "metadata variables to exclude"
---

```{r tackle.setup, include=FALSE}
library(tidymodels)
library(cmapR)
library(magrittr)
library(gt)
library(fs)
library(purrr)
library(ggpubr)
library(tibble)
```


# logging
```{r label=tackle-logging}
MESSAGE<-T
WARNING<-T
```
# load


```{r label=tackle.load}
print(params$color)
PATH <- "."
gct_files <- fs::dir_ls(
  path = PATH,
  recurse = TRUE,
  regexp = ".gct"
 )


( gct_files )

gcts <- gct_files %>% 
purrr::map(
  cmapR::parse_gctx
)

```

# funcs
```{r, label=tackle-funcs}

myzscore <- function(value, minval = NA, remask = TRUE) {
  mask <- is.na(value)
  if (is.na(minval)) minval <- min(value, na.rm = TRUE)
  value[is.na(value)] <- minval
  out <- scale(value)
  if (remask == TRUE) {
    out[mask] <- NA
  }
  return(out)
}
dist_no_na <- function(mat) {
  mat[is.na(mat)] <- min(mat, na.rm = TRUE)
  edist <- dist(mat)
  return(edist)
}
make_new_gct <- function(gct, mat){
  # make a new gct object with the same metadata as the original
  new("GCT", mat=mat,
      rid = gct@rid,
      cid=gct@cid,
      rdesc=gct@rdesc,
      cdesc=gct@cdesc,
        )
}
```


```{r, label='tackle.cdesc'}
.gct <- gcts[[1]]
#.gct@cdesc
.gct@cdesc %>% 
  select(recno, runno, searchno, label, everything()) %>% 
  gt::gt(
  caption="metadata"
)

```


```{r, label=tackle.gctlist}
print(gcts)
```



```{r, label=tackle.onegene, eval=F}
.gct <- gcts[[1]]
.sel <- .gct %>% 
  melt_gct() %>%
  filter(id.x == "928") %>%
  mutate(id.y = factor(id.y, levels=dat@cid, ordered = T)) 
 
.gene <- .sel$rdesc %>% unique
.sel %>% 
  ggpubr::ggbarplot(x='id.y', y="value",
                  title = .gene,
                  color = params$color) %>%
  ggpar(x.text.angle = 90)
```


# results {.tabset}

## metrics
```{r, label="tackle.metrics"}
gcts %>% map(
  ~cmapR::mat(.) %>% dim
)
gct <- gcts[[1]]
# all below analysis is written to analyze 1 gct object
```

## cluster
### heatmap

### kmeans

here z score and any other xformations take place
```{r eval=F}
# from https://www.tidymodels.org/learn/statistics/k-means/
#CLUSTER_RANGE <- seq(params$CLUSTER_RANGE_LOWER, params$CLUSTER_RANGE_HIGHER, 1)
CLUSTER_RANGE=seq(3,7)


# if z score is true
# what's easier way to do this?
.forcluster <- mat(.gct) %>% head(500)
.forcluster %<>% apply(MARGIN=1, FUN=myzscore) %>% t() %>% as.matrix()
colnames(.forcluster) <- colnames(mat(.gct))
.gct_zscored <- make_new_gct(.gct, .forcluster)
#colnames(.forcluster) <- .gct@cid
#.cluster_func <- function(n, ...) kmeans(.tocluster, n, ...)

kclusts <-  tibble(n=seq(CLUSTER_RANGE)) %>%
  mutate(
    #kclust = map(n, ~.cluster_func(n=.x)),
    kclust = map(n, ~kmeans(mat(.gct_zscored), centers=.x))
  ) 

kclusts %<>% 
  mutate(
    tidied = map(kclust, tidy),
    glanced = map(kclust, glance),
    augmented = map(kclust, augment, .forcluster)
  
)
```

render cluster.Rmd
```{r, label=tackle-cluster, message=T, warning=T, results='show', eval=T}

.params <- params$cluster

#.params$method <- "kmeans"

render_cluster_report <- function(method="kmeans"){
  .output_file_name <- paste0("cluster_", "method_", method, ".html")
  rmarkdown::render("cluster.Rmd", 
              output_file=.output_file_name,
              params=list(method=method)
              #params=.params,
              #envir = globalenv(),
              #envir = new_env
              #documentation=1,
              )
  return(.output_file_name)
  
}
.out <- render_cluster_report(method='kmeans')
htmltools::includeHTML(.out)
.out <- render_cluster_report(method='PAM')
htmltools::includeHTML(.out)
  
#htmltools::includeHTML("cluster1.html")

```

```{r eval=F}
#[cluster](cluster.html)
```


```{r eval=F}

clusters <- 
  kclusts %>%
  unnest(cols = c(tidied))

assignments <- 
  kclusts %>% 
  unnest(cols = c(augmented))

clusterings <- 
  kclusts %>%
  unnest(cols = c(glanced))
```


```{r eval=F}
ggplot(clusterings, aes(n, tot.withinss)) +
  geom_line() +
  geom_point() +
  scale_x_discrete(limits=seq(CLUSTER_RANGE) %>% as.factor() ) +
  ggpubr::theme_pubclean()
  #scale_x_discrete(limits=breaks_pretty())
  #breaks_pretty() +

```

```{r eval=F}
chosen_cluster <- assignments %>% filter(n==elbow_cluster_sel)
```


### cluster
```{r eval=F}


.negsel <- c('sample', 'plex', 'recno', 'label', 'id', 'runno', 'searchno', 'assay', 'replicate')
.column_df <- .gct@cdesc %>% select(-any_of(.negsel))
# kmeans logic
library(ComplexHeatmap)


.color_list <- .column_df %>% as.list %>% map( ~ brewer_pal("qual", palette=2)(length(unique(.))) )

# fix this maybe if better
for (col in colnames(.column_df)){
  #print(col)
    names(.color_list[[col]]) <-  unique(.column_df[[col]])
}

.top_annotation = columnAnnotation( df = .column_df, col = .color_list )


.make_heatmap_row_cluster <- function(.x, ...){
  
  #.row_annot <- rowAnnotation(.x$.cluster)
  .samplenames <- .gct@cid
  
  .h <- ComplexHeatmap::Heatmap(
    .x %>% dplyr::select(.samplenames),
    row_split = .x$.cluster,
    #.forcluster %>% head(300),
    #top_annotation = .top_annotation,
    clustering_distance_rows = dist_no_na,
    clustering_distance_columns =  dist_no_na,
    column_title_side="top",
    column_title_rot = 0,
    column_names_gp = gpar(fontsize=9),
    border=TRUE,
    use_raster=T,
    show_row_names=F,
    ...
)
  .h
}


#.X <- chosen_cluster %>% select(.gct@cid) # grab all the numerical values from the dataframe with the chosen cluster
chosen_cluster %>% .make_heatmap_row_cluster() %>% print

```


render PCA.Rmd
```{r, label=tackle-pca, message=T, warning=T, results='show', eval=T}

.params <- params$cluster

#.params$method <- "kmeans"

render_pca_report <- function(center=T, scale=F){
  .output_file_name <- paste0("PCA", "center_", center, "scale_", scale, ".html")
  rmarkdown::render("PCA.Rmd", 
              output_file=.output_file_name,
              params=list(
                center=center,
                scale=scale
              )
              #params=.params,
              #envir = globalenv(),
              #envir = new_env
              #documentation=1,
              )
  return(.output_file_name)
  
}

## {-}

# another section

